+++
title = "C言語でソケットプログラミング(1)"
date = 2020-05-05
lastmod = 2020-05-05
tags = ["study"]
categories = []
imgs = []
cover = ""  # image show on top
readingTime = 5  # show reading time after article date
toc = true
comments = false
justify = false  # text-align: justify;
single = false  # display as a single page, hide navigation on bottom, like as about page.
license = ""  # CC License
draft = true
+++

現在[SmartDrive](https://smartdrive.co.jp/)で 3rd Party デバイスから送られる様々なセンサーデータを弊社の Platform に変換して投げ込む Adapter を開発してます。

デバイスや会社によってデータの投げ込まれ方の仕様が異なるのですが、あるデバイスでは HTTP ではなく独自プロトコルの TCP 通信を行う必要があり、
これを実装するにあたってソケットプログラミングを学ぶ必要がありました。

そもそもサーバーとクライアントはどのように繋がって通信を行っているのか、C 言語でソケットプログラミングして学んでみました。
ちなみに自分は C 言語もシステムコールプログラミングも素人で、TCP/IP の基礎は[マスタリング TCP/IP](https://www.amazon.co.jp/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0TCP-IP-%E5%85%A5%E9%96%80%E7%B7%A8-%E7%AC%AC5%E7%89%88-%E7%AB%B9%E4%B8%8B/dp/4274068765)で理解している程度です。

## コード

最初にサーバーを起動してクライアントを起動すれば `HELLO 5` がサーバーから送られてコネクションが切れるものを書きました。最初に完成コードを載せます。

`server.c`

```
#include <netinet/in.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>

int main()
{
  int sock0;
  struct sockaddr_in addr;
  struct sockaddr_in client;
  int len;
  int sock;

  sock0 = socket(AF_INET, SOCK_STREAM, 0);

  addr.sin_family = AF_INET;
  addr.sin_port = htons(12345);
  addr.sin_addr.s_addr = INADDR_ANY;

  bind(sock0, (struct sockaddr *)&addr, sizeof(addr));

  listen(sock0, 5);

  len = sizeof(client);
  sock = accept(sock0, (struct sockaddr *)&client, &len);

  write(sock, "HELLO", 5);

  close(sock);

  close(sock0);
  return 0;
}
```

`client.c`

```
#include <netinet/in.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>

int main()
{
  struct sockaddr_in server;
  int sock;
  char buf[32];
  int n;

  sock = socket(AF_INET, SOCK_STREAM, 0);

  server.sin_family = AF_INET;
  server.sin_port = htons(12345);
  server.sin_addr.s_addr = inet_addr("127.0.0.1");

  connect(sock, (struct sockaddr *)&server, sizeof(server));

  memset(buf, 0, sizeof(buf));
  n = read(sock, buf, sizeof(buf));

  printf("%d, %s\n", n, buf);

  close(sock);

  return 0;
}
```

## システムコールとは

CPU にはいくつかの動作モードがあります。コンピュータアーキテクチャの 1 つに複数の特権レベルを表すリングプロテクションというものがあります。

![リングプロテクション](https://upload.wikimedia.org/wikipedia/commons/2/2f/Priv_rings.svg)

【画像引用元】[リングプロテクション – Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)

UNIX では 0 と 3 の 2 階層を使用し、0 は **カーネルモード** 3 は **ユーザーモード** と呼ばれます。
システムコールとは **カーネルモード** でのみ許される OS 機能を **ユーザーモード** のアプリから実行することです。
プロセスは通常ユーザーモードで動作してますが、システムコールを発行することで CPU 上で割り込みイベントを発生させ実行できます。

- socket(2)
  - ソケットを作成するシステムコール。ファイルディスクリプタを返す。

- ファイルディスクリプタとは?
  - OS の世界では通信やあらゆる外部リソースをファイルとして抽象化して扱い、それを`read`または`write`することでデータの読み書きを行う。ファイルディスクリプタはそのファイル識別の番号。

- bind(2)
  - ソケットに IP アドレス, ポート番号等を割り当てる。

- listen(2)
  - TCP クライアントからの接続要求を待てる状態にする。backlog に保留中のキューの max を入れる。

- accept(2)
  - TCP クライアントからの接続要求が来るまでプログラムを停止し接続後にプログラムを再開、dynamic port を割り当てる。

- connect(2)
  - ソケット経由で接続開始する。

- write(2)
  - ファイルディスクリプタに書き込む。

- read(2)
  - ファイルディスクリプタから読み込む。

- close(2)
  - ファイルディスクリプタを閉じて再使用可能にする。

## 次やること

これは一度通信を行えば処理が終了します。また、1つのクライアントにしか対応できません。
なので次はマルチスレッドによる多重化をしてみます。
