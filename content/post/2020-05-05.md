+++
title = "C言語でソケットプログラミング(1)"
date = 2020-05-05
lastmod = 2020-05-05
tags = ["study"]
categories = []
imgs = []
cover = ""  # image show on top
readingTime = 5  # show reading time after article date
toc = true
comments = false
justify = false  # text-align: justify;
single = false  # display as a single page, hide navigation on bottom, like as about page.
license = ""  # CC License
draft = true
+++

現在[SmartDrive](https://smartdrive.co.jp/)で3rd Partyデバイスから送られる様々なセンサーデータを弊社のPlatformに変換して投げ込むAdapterを開発してます。

デバイスや会社によってデータの投げ込まれ方の仕様が異なるのですが、あるデバイスではHTTPではなく独自プロトコルのTCP通信を行う必要があり、
これを実装するにあたってソケットプログラミングを学ぶ必要がありました。

そもそもサーバーとクライアントはどのように繋がって通信を行っているのか、C言語でソケットプログラミングして学んでみました。
ちなみに自分はC言語もシステムコールプログラミングも素人で、TCP/IPの基礎は[マスタリングTCP/IP](https://www.amazon.co.jp/%E3%83%9E%E3%82%B9%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0TCP-IP-%E5%85%A5%E9%96%80%E7%B7%A8-%E7%AC%AC5%E7%89%88-%E7%AB%B9%E4%B8%8B/dp/4274068765)で理解している程度です。

## コード
最初にサーバーを起動してクライアントを起動すれば `HELLO 5` がサーバーから送られてコネクションが切れるものを書きました。最初に完成コードを載せます。

`server.c`
```
#include <netinet/in.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>

int main()
{
  int sock0;
  struct sockaddr_in addr;
  struct sockaddr_in client;
  int len;
  int sock;

  sock0 = socket(AF_INET, SOCK_STREAM, 0);

  addr.sin_family = AF_INET;
  addr.sin_port = htons(12345);
  addr.sin_addr.s_addr = INADDR_ANY;

  bind(sock0, (struct sockaddr *)&addr, sizeof(addr));

  listen(sock0, 5);

  len = sizeof(client);
  sock = accept(sock0, (struct sockaddr *)&client, &len);

  write(sock, "HELLO", 5);

  close(sock);

  close(sock0);
  return 0;
}
```

`client.c`
```
#include <netinet/in.h>
#include <stdio.h>
#include <sys/socket.h>
#include <sys/types.h>

int main()
{
  struct sockaddr_in server;
  int sock;
  char buf[32];
  int n;

  sock = socket(AF_INET, SOCK_STREAM, 0);

  server.sin_family = AF_INET;
  server.sin_port = htons(12345);
  server.sin_addr.s_addr = inet_addr("127.0.0.1");

  connect(sock, (struct sockaddr *)&server, sizeof(server));

  memset(buf, 0, sizeof(buf));
  n = read(sock, buf, sizeof(buf));

  printf("%d, %s\n", n, buf);

  close(sock);

  return 0;
}
```

## システムコールとは
CPUにはいくつかの動作モードがあります。コンピュータアーキテクチャの1つに複数の特権レベルを表すリングプロテクションというものがあります。

![リングプロテクション](https://upload.wikimedia.org/wikipedia/commons/2/2f/Priv_rings.svg)

【画像引用元】[リングプロテクション – Wikipedia](https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%97%E3%83%AD%E3%83%86%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)

UNIXでは0と3の2階層を使用し、0は **カーネルモード** 3は **ユーザーモード** と呼ばれます。
システムコールとは **カーネルモード** でのみ許されるOS機能を **ユーザーモード** のアプリから実行することです。

プロセスは通常ユーザーモードで動作してますが、システムコールを発行することでCPU上で割り込みイベントを発生させ実行できます。

- socket(2)
  - ソケットを作成するシステムコール。ファイルディスクリプタを返す。

- ファイルディスクリプタとは?
  - OSの世界では通信やあらゆる外部リソースをファイルとして抽象化して扱い、それを`read`または`write`することでデータの読み書きを行う。ファイルディスクリプタはそのファイル識別の番号。

- bind(2)
  - ソケットにIPアドレス, ポート番号等を割り当てる。

- listen(2)
  - TCPクライアントからの接続要求を待てる状態にする。backlogに保留中のキューのmaxを入れる。

- accept(2)
  - TCPクライアントからの接続要求が来るまでプログラムを停止し接続後にプログラムを再開、dynamic portを割り当てる。

- connect(2)
  - ソケット経由で接続開始する。

- write(2)
  - ファイルディスクリプタに書き込む。

- read(2)
  - ファイルディスクリプタから読み込む。

- close(2)
  - ファイルディスクリプタを閉じて再使用可能にする。

## 次やりたい
これは一度通信を行えば処理が終了します。また、1つのクライアントにしか対応できません。
なので次はマルチスレッドによる多重化をしてみます。クライアントからの接続を待ち子スレッドを生成するメインスレッドと、実際に通信を行う子スレッド構成のもの。
